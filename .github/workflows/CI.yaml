name: Build, Push, Update Manifests & Publish Helm

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: build-push-helm
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  build_publish_all:
    runs-on: ubuntu-latest

    env:
      # ===== App / Docker =====
      IMAGE_NAME: ritatrcr/delivery-app
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}

      # ===== Git / PAT (RW en ambos repos externos) =====
      GH_USER: ritatrcr
      PAT_TOKEN: ${{ secrets.PAT_HELMCHART }}

      # ===== Repos externos =====
      HELM_MANIFESTS_REPO: ritatrcr/manifiestos-delivery-app     # chart fuente + values-*.yaml
      HELM_PAGES_REPO:     ritatrcr/helm-chart                   # GitHub Pages (index.yaml)
      HELM_PAGES_BRANCH:   main
      HELM_REPO_URL:       https://ritatrcr.github.io/helm-chart/

      # ===== Ruta del chart dentro del repo de manifiestos =====
      HELM_CHART_DIR: charts/pedido-app
      HELM_CHART_NAME: pedido-app

    steps:
      - name: Checkout (este repo: código de la app)
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Set up Node (para bump de package.json si aplica)
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.15.2

      - name: Install yq
        run: |
          set -euxo pipefail
          YQ_VERSION=v4.44.3
          sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          sudo chmod +x /usr/local/bin/yq
          yq --version
          helm version

      # ---------- APP VERSION ----------
      # Si tu app no es Node, puedes calcular una versión con fecha+sha y exportarla a APP_VERSION.
      - name: Bump app version (patch) y commit [skip ci]
        working-directory: ./delivery-app
        run: |
          set -euxo pipefail
          if [ -f package.json ]; then
            CUR=$(node -e "console.log(require('./package.json').version)")
            npm version patch --no-git-tag-version
            NEW=$(node -e "console.log(require('./package.json').version)")
            echo "APP_VERSION=$NEW" >> "$GITHUB_ENV"
            cd ..
            git config user.name  "github-actions"
            git config user.email "github-actions@github.com"
            git add delivery-app/package.json delivery-app/package-lock.json || true
            git commit -m "chore(ci): bump app version $CUR -> $NEW [skip ci]" || true
            git push || true
          else
            # Plan B: version semántica basada en fecha + corto del sha
            NEW="$(date +%Y.%m.%d).${GITHUB_SHA::7}"
            echo "APP_VERSION=$NEW" >> "$GITHUB_ENV"
          fi

      - name: Ensure APP_VERSION env
        run: |
          set -euxo pipefail
          if [ -z "${APP_VERSION:-}" ]; then
            if [ -f ./delivery-app/package.json ]; then
              echo "APP_VERSION=$(node -e "console.log(require('./delivery-app/package.json').version)")" >> "$GITHUB_ENV"
            else
              echo "APP_VERSION=$(date +%Y.%m.%d).${GITHUB_SHA::7}" >> "$GITHUB_ENV"
            fi
          fi
          echo "APP_VERSION=$APP_VERSION"

      # ---------- DOCKER BUILD & PUSH ----------
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Build & Push image (multi-arch)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:v${{ env.APP_VERSION }}
            ${{ env.IMAGE_NAME }}:${{ env.APP_VERSION }}-${{ github.sha }}
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ---------- CHECKOUT REPO DE MANIFIESTOS ----------
      - name: Checkout manifests repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.HELM_MANIFESTS_REPO }}
          ref: main
          path: manifests
          token: ${{ env.PAT_TOKEN }}
          persist-credentials: false

      # === Punto CLAVE: actualizar tags donde Argo los lee (values-dev/prod) ===
      - name: Actualizar values-dev/prod con imagen y Chart.yaml
        env:
          IMAGE: ${{ env.IMAGE_NAME }}
          TAG: v${{ env.APP_VERSION }}
        run: |
          set -euxo pipefail
          cd manifests

          git config user.name  "github-actions"
          git config user.email "github-actions@github.com"
          git remote set-url origin "https://${GH_USER}:${PAT_TOKEN}@github.com/${HELM_MANIFESTS_REPO}.git"

          CHART_DIR="${HELM_CHART_DIR}"

          bump_values () {
            local FILE="$1"
            if [ -f "$FILE" ]; then
              # Soporta 3 estilos:
              #  1) app.image (tu subchart único)
              #  2) backend.image (si separas backend)
              #  3) frontend.image (si separas frontend)
              yq -i '
                .app = (.app // {}) |
                .app.image = (.app.image // {}) |
                .app.image.repository = strenv(IMAGE) |
                .app.image.tag = strenv(TAG) |
                .app.image.pullPolicy = (.app.image.pullPolicy // "IfNotPresent") |
                .backend = (.backend // .backend) |
                (.backend.image.repository = strenv(IMAGE)) |
                (.backend.image.tag = strenv(TAG)) |
                (.backend.image.pullPolicy = (.backend.image.pullPolicy // "IfNotPresent")) |
                .frontend = (.frontend // .frontend) |
                (.frontend.image.repository = strenv(IMAGE)) |
                (.frontend.image.tag = strenv(TAG)) |
                (.frontend.image.pullPolicy = (.frontend.image.pullPolicy // "IfNotPresent"))
              ' "$FILE"
            else
              echo "::warning::No existe $FILE"
            fi
          }

          bump_values "${CHART_DIR}/values-dev.yaml"
          bump_values "${CHART_DIR}/values-prod.yaml"

          # Alinear versión del Chart con la de la app (evita desfaces al empaquetar)
          if [ -f "${CHART_DIR}/Chart.yaml" ]; then
            yq -i ".version = env(APP_VERSION) | .appVersion = env(APP_VERSION)" "${CHART_DIR}/Chart.yaml"
          else
            echo "::error::No existe ${CHART_DIR}/Chart.yaml"; exit 1
          fi

          git add -A
          git commit -m "chore(values): ${IMAGE}:${TAG} & chart=${APP_VERSION}" || echo "Nada que commitear"
          git push origin main

      # ---------- (Opcional) PUBLICAR CHART EN GITHUB PAGES ----------
      - name: Checkout helm-chart (Pages)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.HELM_PAGES_REPO }}
          ref: ${{ env.HELM_PAGES_BRANCH }}
          path: helm-pages
          token: ${{ env.PAT_TOKEN }}
          persist-credentials: false

      - name: Reset clean branch (helm-pages)
        run: |
          set -euxo pipefail
          cd helm-pages
          git fetch --all
          git checkout "${HELM_PAGES_BRANCH}"
          git reset --hard "origin/${HELM_PAGES_BRANCH}"
          git clean -fdx

      - name: Helm dependency update
        run: |
          set -euxo pipefail
          CHART_SRC="$GITHUB_WORKSPACE/manifests/${HELM_CHART_DIR}"
          helm dependency update "$CHART_SRC"

      - name: Lint + Package chart en helm-pages/
        id: pkg
        run: |
          set -euxo pipefail
          CHART_SRC="$GITHUB_WORKSPACE/manifests/${HELM_CHART_DIR}"

          # Lint
          helm lint "$CHART_SRC"

          # La versión del .tgz DEBE ser la de Chart.yaml (ya alineada con APP_VERSION)
          WANT_VERSION=$(yq -r '.version' "${CHART_SRC}/Chart.yaml")
          echo "WANT_VERSION=$WANT_VERSION"

          # Empaquetar en helm-pages/
          helm package "$CHART_SRC" -d "$GITHUB_WORKSPACE/helm-pages"

          # Verificar .tgz generado y su versión
          PKG_PATH="$(ls -1t "$GITHUB_WORKSPACE/helm-pages/${HELM_CHART_NAME}-"*.tgz | head -n 1)"
          test -f "$PKG_PATH"
          PKG_FILE="$(basename "$PKG_PATH")"
          CHART_VERSION="${PKG_FILE#${HELM_CHART_NAME}-}"
          CHART_VERSION="${CHART_VERSION%.tgz}"
          echo "PKG_PATH=$PKG_PATH" >> "$GITHUB_OUTPUT"
          echo "CHART_VERSION=$CHART_VERSION" >> "$GITHUB_OUTPUT"
          [ "$CHART_VERSION" = "$WANT_VERSION" ]

      - name: Update index.yaml (merge) y push a helm-chart
        run: |
          set -euxo pipefail
          cd helm-pages
          if [ -f index.yaml ]; then
            helm repo index . --url "${HELM_REPO_URL}" --merge index.yaml
          else
            helm repo index . --url "${HELM_REPO_URL}"
          fi
          git config user.name  "github-actions"
          git config user.email "github-actions@github.com"
          git add -A
          git commit -m "Publish chart ${HELM_CHART_NAME} ${{ steps.pkg.outputs.CHART_VERSION }}" || echo "Nada que commitear"
          git remote set-url origin "https://${GH_USER}:${PAT_TOKEN}@github.com/${HELM_PAGES_REPO}.git"
          git push origin "${HELM_PAGES_BRANCH}"

      - name: Echo repo usage
        run: |
          echo "Repositorio Helm: ${HELM_REPO_URL}"
          echo "Comandos:"
          echo "  helm repo add pedidos ${HELM_REPO_URL}"
          echo "  helm repo update"
          echo "  helm search repo pedidos/${HELM_CHART_NAME}"
